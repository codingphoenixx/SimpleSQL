package dev.coph.simplesql.query.providers;

import dev.coph.simplesql.database.attributes.*;
import dev.coph.simplesql.driver.DriverCompatibility;
import dev.coph.simplesql.driver.DriverType;
import dev.coph.simplesql.exception.FeatureNotSupportedException;
import dev.coph.simplesql.query.Query;
import dev.coph.simplesql.query.QueryEntry;
import dev.coph.simplesql.query.QueryProvider;
import dev.coph.simplesql.utils.DatabaseCheck;
import dev.coph.simpleutilities.action.RunnableAction;
import dev.coph.simpleutilities.check.Check;

import java.util.*;

/**
 * UpdateQueryProvider is a class that implements the QueryProvider interface
 * and provides functionality for constructing and customizing SQL UPDATE queries.
 * This class allows users to specify update components such as table name,
 * update priority, entries to be updated, conditions, order, and limits, as well
 * as logic to execute after the query is performed. The queries generated by the class
 * are compatible with MySQL and MariaDB drivers.
 */
public class UpdateQueryProvider implements QueryProvider {

    private String table;
    private UpdatePriority updatePriority = UpdatePriority.NORMAL;
    private boolean updateIgnore = false;
    private List<QueryEntry> entries;
    private List<Object> boundParams = List.of();

    private LinkedHashSet<Condition> conditions;
    private Order order;
    private Limit limit;
    private RunnableAction<Boolean> actionAfterQuery;

    /**
     * Sets the order configuration for the current query. If an order is already set,
     * the new order's rules will be merged with the existing order rules.
     * This method supports method chaining to allow fluent API usage.
     *
     * @param order the {@code Order} object containing ordering rules to be applied
     * @return the current instance of {@code UpdateQueryProvider} for method chaining
     */
    public UpdateQueryProvider order(Order order) {
        if (this.order == null)
            this.order = order;
        else
            this.order.orderRules().putAll(order.orderRules());
        return this;
    }

    /**
     * Adds an ordering rule to the current query using the specified column/key and direction.
     * If no ordering rules exist, a new {@code Order} object is initialized.
     * This method supports method chaining to allow fluent API usage.
     *
     * @param key       the name of the column or key to apply the ordering rule on
     * @param direction the direction of the order, either ascending or descending,
     *                  specified as {@code Order.Direction}
     * @return the current instance of {@code UpdateQueryProvider} for method chaining
     */
    public UpdateQueryProvider order(String key, Order.Direction direction) {
        if (this.order == null)
            this.order = new Order();
        order.rule(key, direction);
        return this;
    }

    /**
     * Sets the maximum number of records (limit) for the query.
     * If the limit configuration is not already initialized, it will
     * create a new {@code Limit} instance and apply the given value.
     * This method supports method chaining to allow fluent API usage.
     *
     * @param limit the maximum number of records to retrieve
     * @return the current instance of {@code UpdateQueryProvider} for method chaining
     */
    public UpdateQueryProvider limit(int limit) {
        if (this.limit == null)
            this.limit = new Limit();

        this.limit.limit(limit);
        return this;
    }

    /**
     * Sets the limit and offset for the query. If the limit configuration
     * is not already initialized, it will create a new {@code Limit} instance
     * and apply the given values. This method supports method chaining
     * to allow fluent API usage.
     *
     * @param limit  the maximum number of records to retrieve
     * @param offset the number of records to skip before starting to retrieve results
     * @return the current instance of {@code UpdateQueryProvider} for method chaining
     */
    public UpdateQueryProvider limit(int limit, int offset) {
        if (this.limit == null)
            this.limit = new Limit();

        this.limit.limit(limit);
        this.limit.offset(offset);
        return this;
    }

    /**
     * Adds a condition to the current query. If the condition set is uninitialized,
     * a new {@code LinkedHashSet} will be created to store the provided condition.
     * This method supports method chaining to allow fluent API usage.
     *
     * @param condition the {@code Condition} object to be added to the query's condition set
     * @return the current instance of {@code UpdateQueryProvider} for method chaining
     */
    public UpdateQueryProvider condition(Condition condition) {
        if (conditions == null)
            conditions = new LinkedHashSet<>();

        conditions.add(condition);
        return this;
    }

    /**
     * Adds a condition to the current query using the given column and value.
     * If the conditions set is not initialized, a new {@code LinkedHashSet} is created
     * to store the specified condition. This method supports method chaining to allow
     * fluent API usage.
     *
     * @param column the name of the column to apply the condition to
     * @param value  the value to be used in the condition
     * @return the current instance of {@code UpdateQueryProvider} for method chaining
     */
    public UpdateQueryProvider condition(String column, Object value) {
        if (conditions == null)
            conditions = new LinkedHashSet<>();

        conditions.add(new Condition(column, value));
        return this;
    }

    /**
     * Adds a condition to the query using the specified column, operator, and value.
     *
     * @param column   the name of the column to apply the condition to
     * @param operator the operator to use for the condition (e.g., EQUALS, GREATER_THAN)
     * @param value    the value to compare the column against
     * @return the updated instance of {@code UpdateQueryProvider} with the added condition
     */
    public UpdateQueryProvider condition(String column, Operator operator, Object value) {
        if (conditions == null)
            conditions = new LinkedHashSet<>();

        conditions.add(new Condition(column, operator, value));
        return this;
    }

    /**
     * Adds a new entry to the query with the specified column name and value.
     *
     * @param column the name of the column to be updated
     * @param value the value to be set for the specified column
     * @return the current instance of UpdateQueryProvider to allow method chaining
     */
    public UpdateQueryProvider entry(String column, Object value) {
        if (entries == null)
            entries = new ArrayList<>();

        entries.add(new QueryEntry(column, value));
        return this;
    }

    /**
     * Adds a QueryEntry object to the list of entries. If the list of entries is null, it initializes the list before adding the entry.
     *
     * @param entry the QueryEntry object to be added to the entries list
     * @return the current instance of UpdateQueryProvider
     */
    public UpdateQueryProvider entry(QueryEntry entry) {
        if (entries == null)
            entries = new ArrayList<>();

        entries.add(entry);
        return this;
    }

    @Override
    public DriverCompatibility compatibility() {
        return driverType -> true;
    }


    @Override
    public String generateSQLString(Query query) {
        Check.ifNullOrEmptyMap(table, "table name");
        Check.ifNullOrEmptyMap(entries, "entries");

        DriverType driver = query.databaseAdapter() != null
                ? query.databaseAdapter().driverType()
                : null;

        List<Object> params = new ArrayList<>();
        StringBuilder sql = new StringBuilder();

        sql.append("UPDATE");

        if (updatePriority == UpdatePriority.LOW) {
            DatabaseCheck.requireDriver(driver, DriverType.MYSQL, DriverType.MARIADB);
            sql.append(" LOW_PRIORITY");
        }

        if (updateIgnore) {
            DatabaseCheck.requireDriver(driver, DriverType.MYSQL, DriverType.MARIADB);
            sql.append(" IGNORE");
        }

        sql.append(" ").append(table).append(" SET ");

        StringJoiner setJoin = new StringJoiner(", ");
        for (QueryEntry e : entries) {
            setJoin.add(e.columName() + " = ?");
            params.add(e.value());
        }
        sql.append(setJoin);

        if (conditions != null && !conditions.isEmpty()) {
            sql.append(" WHERE ");
            String whereFragment = buildWhereAndBind(conditions.iterator(), params);
            sql.append(whereFragment);
        }

        if (order != null && order.orderRules() != null && !order.orderRules().isEmpty()) {
            DatabaseCheck.requireDriver(driver, DriverType.MYSQL, DriverType.MARIADB);
            sql.append(order.toString(query));
        }

        if (limit != null && limit.limit() > 0) {
            DatabaseCheck.requireDriver(driver, DriverType.MYSQL, DriverType.MARIADB);

            if (limit.offset() > 0) {
                if (order == null || order.orderRules() == null || order.orderRules().isEmpty()) {
                    throw new FeatureNotSupportedException(driver);
                }
                sql.append(" LIMIT ").append(limit.offset()).append(", ").append(limit.limit());
            } else {
                sql.append(" LIMIT ").append(limit.limit());
            }
        } else if (limit != null && limit.offset() > 0) {
            DatabaseCheck.requireDriver(driver, DriverType.MYSQL, DriverType.MARIADB);
            throw new FeatureNotSupportedException(driver);
        }

        sql.append(";");        
        for (int i = 0, paramsSize = params.size(); i < paramsSize; i++) {
            Object p = params.get(i);
            if (p == null) {
                throw new IllegalArgumentException("Parameter list contains null value at slot %s".formatted(i + 1));
            }
        }
        
        this.boundParams = List.copyOf(params);
        return sql.toString();
    }

    private String buildWhereAndBind(Iterator<Condition> it, List<Object> params) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        while (it.hasNext()) {
            Condition c = it.next();
            if (!first) {
                sb.append(c.type() == Condition.Type.AND ? " AND " : " OR ");
            }
            if (c.not()) sb.append("NOT ");

            String column = c.key();
            Operator op = c.operator();
            Object value = c.value();

            switch (op) {
                case IS_NULL -> sb.append(column).append(" IS NULL");
                case IS_NOT_NULL -> sb.append(column).append(" IS NOT NULL");
                default -> {
                    sb.append(column).append(" ").append(op.operator()).append(" ?");
                    params.add(value);
                }
            }

            first = false;
        }
        return sb.toString();
    }


    @Override
    public List<Object> parameters() {
        return boundParams != null ? boundParams : List.of();
    }

    /**
     * Retrieves the name of the table associated with the current query provider.
     *
     * @return the name of the table as a String
     */
    public String table() {
        return this.table;
    }

    /**
     * Retrieves the current update priority for the update operation.
     *
     * @return the current {@code UpdatePriority} associated with the update operation.
     */
    public UpdatePriority updatePriority() {
        return this.updatePriority;
    }

    /**
     * Retrieves the current state of the update ignore flag.
     * The update ignore flag determines whether update operations should ignore
     * rows that conflict with certain conditions, such as unique constraints.
     *
     * @return {@code true} if the update ignore flag is enabled,
     *         otherwise {@code false}.
     */
    public boolean updateIgnore() {
        return this.updateIgnore;
    }

    /**
     * Retrieves a list of query entries associated with the current query provider.
     * Each entry represents a column and its corresponding value used in update operations.
     *
     * @return a list of {@code QueryEntry} objects representing the column-value pairs
     */
    public List<QueryEntry> entries() {
        return this.entries;
    }

    /**
     * Retrieves the set of conditions associated with the current query provider.
     * Conditions define the constraints or filters applied to the update operations.
     *
     * @return a {@code Set} of {@code Condition} objects representing the conditions.
     */
    public Set<Condition> conditions() {
        return this.conditions;
    }

    /**
     * Retrieves the limit configuration associated with the current query provider.
     * The limit configuration defines the maximum number of records and the offset
     * used for pagination or query results.
     *
     * @return the {@code Limit} object representing the limit and offset configuration
     */
    public Limit limit() {
        return this.limit;
    }

    /**
     * Sets the name of the table to be used in the update query.
     *
     * @param table the name of the table
     * @return the current instance of {@code UpdateQueryProvider} for method chaining
     */
    public UpdateQueryProvider table(String table) {
        this.table = table;
        return this;
    }

    /**
     * Sets the priority level for the update operation.
     * UpdatePriority can define the urgency or significance of the update operation.
     *
     * @param updatePriority the {@code UpdatePriority} to set for the update operation
     * @return the current instance of {@code UpdateQueryProvider} for method chaining
     */
    public UpdateQueryProvider updatePriority(UpdatePriority updatePriority) {
        this.updatePriority = updatePriority;
        return this;
    }

    /**
     * Sets whether the update operation should ignore rows that conflict with certain conditions,
     * such as unique constraints. The configuration is updated based on the provided flag.
     * This method allows for method chaining by returning the current instance.
     *
     * @param updateIgnore a boolean value indicating whether to enable or disable
     *                     the update ignore flag. {@code true} to ignore conflicts,
     *                     {@code false} to handle conflicts normally.
     * @return the current instance of {@code UpdateQueryProvider} for method chaining.
     */
    public UpdateQueryProvider updateIgnore(boolean updateIgnore) {
        this.updateIgnore = updateIgnore;
        return this;
    }

    /**
     * Sets the action to be executed after the query is run.
     * This method allows defining a post-query action and supports method chaining.
     *
     * @param actionAfterQuery the {@code RunnableAction<Boolean>} to be executed post-query.
     *                         The {@code Boolean} parameter in the action represents the
     *                         success or failure of the query execution.
     * @return the current instance of {@code UpdateQueryProvider} for method chaining.
     */
    public UpdateQueryProvider actionAfterQuery(RunnableAction<Boolean> actionAfterQuery) {
        this.actionAfterQuery = actionAfterQuery;
        return this;
    }

    @Override
    public RunnableAction<Boolean> actionAfterQuery() {
        return actionAfterQuery;
    }
}
